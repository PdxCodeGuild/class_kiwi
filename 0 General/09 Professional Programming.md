

# Programming


- [Programming-Related Careers](#programming-related-careers)
- [The Software Development Life-Cycle (SDLC)](#the-software-development-life-cycle-sdlc)
  - [1) Requirements Gathering](#1-requirements-gathering)
  - [2) Design](#2-design)
  - [3) Implementation](#3-implementation)
  - [4) Testing](#4-testing)
  - [5) Deployment](#5-deployment)
  - [6) Maintenance](#6-maintenance)
- [Wireframing Tools](#wireframing-tools)
- [Diagramming Tools](#diagramming-tools)

## Programming-Related Careers

- Software Development
  - Desktop Development
  - Mobile Development
  - Web Development
  - Embedded Systems
- Project Management
- Technical Writing
- Design
- Data Science
- Database Administration
- Quality Assurance
- Information Technology
- Network Administration


## The Software Development Life-Cycle (SDLC)

There are many different methodologies for developing software, and some good general guidelines have developed over the years. You can think of the SDLC generally following the following stages. Going through the stages across an entire project is called the [Waterfall Model](https://en.wikipedia.org/wiki/Waterfall_model). [Agile](https://en.wikipedia.org/wiki/Agile_software_development) and [Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)) go through this cycle repeatedly on shorter timelines. If your requirements are static and well-defined, waterfall is advantageous because there's a direct path of development and we can minimize overhead. However if your requirements might change or your client is capricious, agile approaches are more effective because they're adaptive.

Agile software development involves taking a project in chunks and completing those over shorter 2-week sprints. This provides the customer with something tangible, involves them in the process, and can be adaptive to changing requirements. It also emphasizes face-to-face interaction, pair programming, and the quality of code. Scrum is a particular methodology and comes with specific practices, such as daily stand-up meetings, a task board.


| step | description |
| ---  | ---         |
| requirements gathering] | defining the problem context |
| design, planning | defining the solution  |
| implementation | actual coding |
| testing | ensuring the application meets the original requirements |
| deployment | creating a production environment for end-users to access |
| maintenance | debugging, adding extensions |



### 1) Requirements Gathering

This phase is arguably the most important, because it defines the problem to be solved. The more specific the problem context, the more direct and effective the development process can be. It often involves meeting with clients/stakeholders at their workplace to understand their needs and those of the users. It may also involve research and consulting with subject-matter experts, identifying the source of revenue, and considering existing solutions.

### 2) Design

The design phase involves defining the structure and mechanics of the solution. This involves researching and deciding which libraries and frameworks will be used. It may also involve prototyping and writing out psuedocode. Wireframes are drawings of web pages or other UI to understand the functionality and layout. Mockups show what the end-product will look like. Database diagrams show the the tables, columns and relationships. Use case diagrams show the interaction of the user with the system. Infrastructure diagrams show the interaction between the different components of the application (server, database, APIs, etc).



### 3) Implementation

During the implementation phase, developers actually write code.

### 4) Testing

There are many different forms of testing.

- Unit tests isolate specific components and ensure that they behave as expected.
- Integrating tests involve the relationship between components.
- Regression tests are performed after adding a new feature to ensure all other features still work as expected.
- Black-box testing involves deliberately ignoring the internals of a components or system to focus on the input and output. White-box testing involves the internals.
- User testing involves end-users (or people similar to the end-users), who can give feedback on their experiences.


### 5) Deployment

Deployment involves putting the application into production, an environment where it's accessible to the end users. This involves researching and choosing a hosting service, configuring a server, setting DNS records, ensuring access is secure, etc.

### 6) Maintenance

Software does not degrade like physical objects, but it still requires maintenance to keep up with advancing requirements, browsers, libraries, etc.

## Wireframing Tools

- https://wireframe.cc/
- https://www.lucidchart.com/
- https://mockflow.com/
- http://pencil.evolus.vn/
- https://www.gliffy.com/
- https://balsamiq.com/ (paid)

## Diagramming Tools

- [Google Drawings](https://docs.google.com/drawings/)
- [Pencil Project](https://pencil.evolus.vn/)
- [yEd Graph Editor](https://www.yworks.com/products/yed)
- [draw.io](https://www.draw.io/)
- [OpenOffice Draw](https://www.openoffice.org/product/draw.html)
- [LibreOffice Draw](https://www.libreoffice.org/)
- [Lucid Chart](https://www.lucidchart.com/) (free w/ limitations)
- [Creately](https://creately.com) (free w/ limitations)
- [Microsoft Visio](https://products.office.com/en-us/visio/flowchart-software?tab=tabs-1) (paid)
- [Dia](http://dia-installer.de/)
